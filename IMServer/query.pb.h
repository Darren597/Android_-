// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: query.proto

#ifndef PROTOBUF_query_2eproto__INCLUDED
#define PROTOBUF_query_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace muduo {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_query_2eproto();
void protobuf_AssignDesc_query_2eproto();
void protobuf_ShutdownFile_query_2eproto();

class Response;
class Logout;
class LoginRequest;
class UserInfo;
class IMMessage;
class HistoryMessage;

enum Response_ErrorCode {
  Response_ErrorCode_NO_ERROR = 1,
  Response_ErrorCode_DATABASE_EEROR = 2,
  Response_ErrorCode_LOG_OUT = 3
};
bool Response_ErrorCode_IsValid(int value);
const Response_ErrorCode Response_ErrorCode_ErrorCode_MIN = Response_ErrorCode_NO_ERROR;
const Response_ErrorCode Response_ErrorCode_ErrorCode_MAX = Response_ErrorCode_LOG_OUT;
const int Response_ErrorCode_ErrorCode_ARRAYSIZE = Response_ErrorCode_ErrorCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Response_ErrorCode_descriptor();
inline const ::std::string& Response_ErrorCode_Name(Response_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Response_ErrorCode_descriptor(), value);
}
inline bool Response_ErrorCode_Parse(
    const ::std::string& name, Response_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Response_ErrorCode>(
    Response_ErrorCode_descriptor(), name, value);
}
enum IMMessage_ConversationType {
  IMMessage_ConversationType_PRIVATE = 1,
  IMMessage_ConversationType_GROUP = 2
};
bool IMMessage_ConversationType_IsValid(int value);
const IMMessage_ConversationType IMMessage_ConversationType_ConversationType_MIN = IMMessage_ConversationType_PRIVATE;
const IMMessage_ConversationType IMMessage_ConversationType_ConversationType_MAX = IMMessage_ConversationType_GROUP;
const int IMMessage_ConversationType_ConversationType_ARRAYSIZE = IMMessage_ConversationType_ConversationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* IMMessage_ConversationType_descriptor();
inline const ::std::string& IMMessage_ConversationType_Name(IMMessage_ConversationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    IMMessage_ConversationType_descriptor(), value);
}
inline bool IMMessage_ConversationType_Parse(
    const ::std::string& name, IMMessage_ConversationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IMMessage_ConversationType>(
    IMMessage_ConversationType_descriptor(), name, value);
}
enum IMMessage_MessageType {
  IMMessage_MessageType_TEXT_MESSGAGE = 1,
  IMMessage_MessageType_IMAGE_MESSGAGE = 2,
  IMMessage_MessageType_VOICE_MESSGAGE = 3
};
bool IMMessage_MessageType_IsValid(int value);
const IMMessage_MessageType IMMessage_MessageType_MessageType_MIN = IMMessage_MessageType_TEXT_MESSGAGE;
const IMMessage_MessageType IMMessage_MessageType_MessageType_MAX = IMMessage_MessageType_VOICE_MESSGAGE;
const int IMMessage_MessageType_MessageType_ARRAYSIZE = IMMessage_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* IMMessage_MessageType_descriptor();
inline const ::std::string& IMMessage_MessageType_Name(IMMessage_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    IMMessage_MessageType_descriptor(), value);
}
inline bool IMMessage_MessageType_Parse(
    const ::std::string& name, IMMessage_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IMMessage_MessageType>(
    IMMessage_MessageType_descriptor(), name, value);
}
// ===================================================================

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Response_ErrorCode ErrorCode;
  static const ErrorCode NO_ERROR = Response_ErrorCode_NO_ERROR;
  static const ErrorCode DATABASE_EEROR = Response_ErrorCode_DATABASE_EEROR;
  static const ErrorCode LOG_OUT = Response_ErrorCode_LOG_OUT;
  static inline bool ErrorCode_IsValid(int value) {
    return Response_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    Response_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    Response_ErrorCode_ErrorCode_MAX;
  static const int ErrorCode_ARRAYSIZE =
    Response_ErrorCode_ErrorCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return Response_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return Response_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return Response_ErrorCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 error_code() const;
  inline void set_error_code(::google::protobuf::int32 value);

  // optional string error_msg = 2;
  inline bool has_error_msg() const;
  inline void clear_error_msg();
  static const int kErrorMsgFieldNumber = 2;
  inline const ::std::string& error_msg() const;
  inline void set_error_msg(const ::std::string& value);
  inline void set_error_msg(const char* value);
  inline void set_error_msg(const char* value, size_t size);
  inline ::std::string* mutable_error_msg();
  inline ::std::string* release_error_msg();
  inline void set_allocated_error_msg(::std::string* error_msg);

  // @@protoc_insertion_point(class_scope:muduo.Response)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_error_msg();
  inline void clear_has_error_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* error_msg_;
  ::google::protobuf::int32 error_code_;
  friend void  protobuf_AddDesc_query_2eproto();
  friend void protobuf_AssignDesc_query_2eproto();
  friend void protobuf_ShutdownFile_query_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class Logout : public ::google::protobuf::Message {
 public:
  Logout();
  virtual ~Logout();

  Logout(const Logout& from);

  inline Logout& operator=(const Logout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Logout& default_instance();

  void Swap(Logout* other);

  // implements Message ----------------------------------------------

  Logout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Logout& from);
  void MergeFrom(const Logout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:muduo.Logout)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_query_2eproto();
  friend void protobuf_AssignDesc_query_2eproto();
  friend void protobuf_ShutdownFile_query_2eproto();

  void InitAsDefaultInstance();
  static Logout* default_instance_;
};
// -------------------------------------------------------------------

class LoginRequest : public ::google::protobuf::Message {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();

  void Swap(LoginRequest* other);

  // implements Message ----------------------------------------------

  LoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int64 user_id() const;
  inline void set_user_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:muduo.LoginRequest)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 user_id_;
  friend void  protobuf_AddDesc_query_2eproto();
  friend void protobuf_AssignDesc_query_2eproto();
  friend void protobuf_ShutdownFile_query_2eproto();

  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::Message {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfo& default_instance();

  void Swap(UserInfo* other);

  // implements Message ----------------------------------------------

  UserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string nickname = 1;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 1;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // required string portrait = 2;
  inline bool has_portrait() const;
  inline void clear_portrait();
  static const int kPortraitFieldNumber = 2;
  inline const ::std::string& portrait() const;
  inline void set_portrait(const ::std::string& value);
  inline void set_portrait(const char* value);
  inline void set_portrait(const char* value, size_t size);
  inline ::std::string* mutable_portrait();
  inline ::std::string* release_portrait();
  inline void set_allocated_portrait(::std::string* portrait);

  // @@protoc_insertion_point(class_scope:muduo.UserInfo)
 private:
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_portrait();
  inline void clear_has_portrait();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* nickname_;
  ::std::string* portrait_;
  friend void  protobuf_AddDesc_query_2eproto();
  friend void protobuf_AssignDesc_query_2eproto();
  friend void protobuf_ShutdownFile_query_2eproto();

  void InitAsDefaultInstance();
  static UserInfo* default_instance_;
};
// -------------------------------------------------------------------

class IMMessage : public ::google::protobuf::Message {
 public:
  IMMessage();
  virtual ~IMMessage();

  IMMessage(const IMMessage& from);

  inline IMMessage& operator=(const IMMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IMMessage& default_instance();

  void Swap(IMMessage* other);

  // implements Message ----------------------------------------------

  IMMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IMMessage& from);
  void MergeFrom(const IMMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef IMMessage_ConversationType ConversationType;
  static const ConversationType PRIVATE = IMMessage_ConversationType_PRIVATE;
  static const ConversationType GROUP = IMMessage_ConversationType_GROUP;
  static inline bool ConversationType_IsValid(int value) {
    return IMMessage_ConversationType_IsValid(value);
  }
  static const ConversationType ConversationType_MIN =
    IMMessage_ConversationType_ConversationType_MIN;
  static const ConversationType ConversationType_MAX =
    IMMessage_ConversationType_ConversationType_MAX;
  static const int ConversationType_ARRAYSIZE =
    IMMessage_ConversationType_ConversationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ConversationType_descriptor() {
    return IMMessage_ConversationType_descriptor();
  }
  static inline const ::std::string& ConversationType_Name(ConversationType value) {
    return IMMessage_ConversationType_Name(value);
  }
  static inline bool ConversationType_Parse(const ::std::string& name,
      ConversationType* value) {
    return IMMessage_ConversationType_Parse(name, value);
  }

  typedef IMMessage_MessageType MessageType;
  static const MessageType TEXT_MESSGAGE = IMMessage_MessageType_TEXT_MESSGAGE;
  static const MessageType IMAGE_MESSGAGE = IMMessage_MessageType_IMAGE_MESSGAGE;
  static const MessageType VOICE_MESSGAGE = IMMessage_MessageType_VOICE_MESSGAGE;
  static inline bool MessageType_IsValid(int value) {
    return IMMessage_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    IMMessage_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    IMMessage_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    IMMessage_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return IMMessage_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return IMMessage_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return IMMessage_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required int32 fromUserId = 2;
  inline bool has_fromuserid() const;
  inline void clear_fromuserid();
  static const int kFromUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 fromuserid() const;
  inline void set_fromuserid(::google::protobuf::int32 value);

  // required .muduo.IMMessage.ConversationType conversationType = 4;
  inline bool has_conversationtype() const;
  inline void clear_conversationtype();
  static const int kConversationTypeFieldNumber = 4;
  inline ::muduo::IMMessage_ConversationType conversationtype() const;
  inline void set_conversationtype(::muduo::IMMessage_ConversationType value);

  // required .muduo.IMMessage.MessageType messageType = 3;
  inline bool has_messagetype() const;
  inline void clear_messagetype();
  static const int kMessageTypeFieldNumber = 3;
  inline ::muduo::IMMessage_MessageType messagetype() const;
  inline void set_messagetype(::muduo::IMMessage_MessageType value);

  // optional .muduo.UserInfo userInfo = 5;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserInfoFieldNumber = 5;
  inline const ::muduo::UserInfo& userinfo() const;
  inline ::muduo::UserInfo* mutable_userinfo();
  inline ::muduo::UserInfo* release_userinfo();
  inline void set_allocated_userinfo(::muduo::UserInfo* userinfo);

  // optional int64 targetId = 6;
  inline bool has_targetid() const;
  inline void clear_targetid();
  static const int kTargetIdFieldNumber = 6;
  inline ::google::protobuf::int64 targetid() const;
  inline void set_targetid(::google::protobuf::int64 value);

  // optional int64 createAt = 7;
  inline bool has_createat() const;
  inline void clear_createat();
  static const int kCreateAtFieldNumber = 7;
  inline ::google::protobuf::int64 createat() const;
  inline void set_createat(::google::protobuf::int64 value);

  // required string extras = 8;
  inline bool has_extras() const;
  inline void clear_extras();
  static const int kExtrasFieldNumber = 8;
  inline const ::std::string& extras() const;
  inline void set_extras(const ::std::string& value);
  inline void set_extras(const char* value);
  inline void set_extras(const char* value, size_t size);
  inline ::std::string* mutable_extras();
  inline ::std::string* release_extras();
  inline void set_allocated_extras(::std::string* extras);

  // @@protoc_insertion_point(class_scope:muduo.IMMessage)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_fromuserid();
  inline void clear_has_fromuserid();
  inline void set_has_conversationtype();
  inline void clear_has_conversationtype();
  inline void set_has_messagetype();
  inline void clear_has_messagetype();
  inline void set_has_userinfo();
  inline void clear_has_userinfo();
  inline void set_has_targetid();
  inline void clear_has_targetid();
  inline void set_has_createat();
  inline void clear_has_createat();
  inline void set_has_extras();
  inline void clear_has_extras();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::google::protobuf::int32 fromuserid_;
  int conversationtype_;
  ::muduo::UserInfo* userinfo_;
  ::google::protobuf::int64 targetid_;
  ::google::protobuf::int64 createat_;
  ::std::string* extras_;
  int messagetype_;
  friend void  protobuf_AddDesc_query_2eproto();
  friend void protobuf_AssignDesc_query_2eproto();
  friend void protobuf_ShutdownFile_query_2eproto();

  void InitAsDefaultInstance();
  static IMMessage* default_instance_;
};
// -------------------------------------------------------------------

class HistoryMessage : public ::google::protobuf::Message {
 public:
  HistoryMessage();
  virtual ~HistoryMessage();

  HistoryMessage(const HistoryMessage& from);

  inline HistoryMessage& operator=(const HistoryMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoryMessage& default_instance();

  void Swap(HistoryMessage* other);

  // implements Message ----------------------------------------------

  HistoryMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoryMessage& from);
  void MergeFrom(const HistoryMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:muduo.HistoryMessage)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_query_2eproto();
  friend void protobuf_AssignDesc_query_2eproto();
  friend void protobuf_ShutdownFile_query_2eproto();

  void InitAsDefaultInstance();
  static HistoryMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// Response

// required int32 error_code = 1;
inline bool Response::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::google::protobuf::int32 Response::error_code() const {
  // @@protoc_insertion_point(field_get:muduo.Response.error_code)
  return error_code_;
}
inline void Response::set_error_code(::google::protobuf::int32 value) {
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:muduo.Response.error_code)
}

// optional string error_msg = 2;
inline bool Response::has_error_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_error_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_error_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_error_msg() {
  if (error_msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_msg_->clear();
  }
  clear_has_error_msg();
}
inline const ::std::string& Response::error_msg() const {
  // @@protoc_insertion_point(field_get:muduo.Response.error_msg)
  return *error_msg_;
}
inline void Response::set_error_msg(const ::std::string& value) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(value);
  // @@protoc_insertion_point(field_set:muduo.Response.error_msg)
}
inline void Response::set_error_msg(const char* value) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(value);
  // @@protoc_insertion_point(field_set_char:muduo.Response.error_msg)
}
inline void Response::set_error_msg(const char* value, size_t size) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:muduo.Response.error_msg)
}
inline ::std::string* Response::mutable_error_msg() {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_msg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:muduo.Response.error_msg)
  return error_msg_;
}
inline ::std::string* Response::release_error_msg() {
  clear_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = error_msg_;
    error_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Response::set_allocated_error_msg(::std::string* error_msg) {
  if (error_msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete error_msg_;
  }
  if (error_msg) {
    set_has_error_msg();
    error_msg_ = error_msg;
  } else {
    clear_has_error_msg();
    error_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:muduo.Response.error_msg)
}

// -------------------------------------------------------------------

// Logout

// -------------------------------------------------------------------

// LoginRequest

// required int64 user_id = 1;
inline bool LoginRequest::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 LoginRequest::user_id() const {
  // @@protoc_insertion_point(field_get:muduo.LoginRequest.user_id)
  return user_id_;
}
inline void LoginRequest::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:muduo.LoginRequest.user_id)
}

// -------------------------------------------------------------------

// UserInfo

// required string nickname = 1;
inline bool UserInfo::has_nickname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_nickname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& UserInfo::nickname() const {
  // @@protoc_insertion_point(field_get:muduo.UserInfo.nickname)
  return *nickname_;
}
inline void UserInfo::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:muduo.UserInfo.nickname)
}
inline void UserInfo::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:muduo.UserInfo.nickname)
}
inline void UserInfo::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:muduo.UserInfo.nickname)
}
inline ::std::string* UserInfo::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:muduo.UserInfo.nickname)
  return nickname_;
}
inline ::std::string* UserInfo::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:muduo.UserInfo.nickname)
}

// required string portrait = 2;
inline bool UserInfo::has_portrait() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_portrait() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_portrait() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_portrait() {
  if (portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    portrait_->clear();
  }
  clear_has_portrait();
}
inline const ::std::string& UserInfo::portrait() const {
  // @@protoc_insertion_point(field_get:muduo.UserInfo.portrait)
  return *portrait_;
}
inline void UserInfo::set_portrait(const ::std::string& value) {
  set_has_portrait();
  if (portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    portrait_ = new ::std::string;
  }
  portrait_->assign(value);
  // @@protoc_insertion_point(field_set:muduo.UserInfo.portrait)
}
inline void UserInfo::set_portrait(const char* value) {
  set_has_portrait();
  if (portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    portrait_ = new ::std::string;
  }
  portrait_->assign(value);
  // @@protoc_insertion_point(field_set_char:muduo.UserInfo.portrait)
}
inline void UserInfo::set_portrait(const char* value, size_t size) {
  set_has_portrait();
  if (portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    portrait_ = new ::std::string;
  }
  portrait_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:muduo.UserInfo.portrait)
}
inline ::std::string* UserInfo::mutable_portrait() {
  set_has_portrait();
  if (portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    portrait_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:muduo.UserInfo.portrait)
  return portrait_;
}
inline ::std::string* UserInfo::release_portrait() {
  clear_has_portrait();
  if (portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = portrait_;
    portrait_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_portrait(::std::string* portrait) {
  if (portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete portrait_;
  }
  if (portrait) {
    set_has_portrait();
    portrait_ = portrait;
  } else {
    clear_has_portrait();
    portrait_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:muduo.UserInfo.portrait)
}

// -------------------------------------------------------------------

// IMMessage

// required string id = 1;
inline bool IMMessage::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMMessage::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMMessage::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMMessage::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& IMMessage::id() const {
  // @@protoc_insertion_point(field_get:muduo.IMMessage.id)
  return *id_;
}
inline void IMMessage::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:muduo.IMMessage.id)
}
inline void IMMessage::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:muduo.IMMessage.id)
}
inline void IMMessage::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:muduo.IMMessage.id)
}
inline ::std::string* IMMessage::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:muduo.IMMessage.id)
  return id_;
}
inline ::std::string* IMMessage::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMMessage::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:muduo.IMMessage.id)
}

// required int32 fromUserId = 2;
inline bool IMMessage::has_fromuserid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMMessage::set_has_fromuserid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMMessage::clear_has_fromuserid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMMessage::clear_fromuserid() {
  fromuserid_ = 0;
  clear_has_fromuserid();
}
inline ::google::protobuf::int32 IMMessage::fromuserid() const {
  // @@protoc_insertion_point(field_get:muduo.IMMessage.fromUserId)
  return fromuserid_;
}
inline void IMMessage::set_fromuserid(::google::protobuf::int32 value) {
  set_has_fromuserid();
  fromuserid_ = value;
  // @@protoc_insertion_point(field_set:muduo.IMMessage.fromUserId)
}

// required .muduo.IMMessage.ConversationType conversationType = 4;
inline bool IMMessage::has_conversationtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMMessage::set_has_conversationtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMMessage::clear_has_conversationtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMMessage::clear_conversationtype() {
  conversationtype_ = 1;
  clear_has_conversationtype();
}
inline ::muduo::IMMessage_ConversationType IMMessage::conversationtype() const {
  // @@protoc_insertion_point(field_get:muduo.IMMessage.conversationType)
  return static_cast< ::muduo::IMMessage_ConversationType >(conversationtype_);
}
inline void IMMessage::set_conversationtype(::muduo::IMMessage_ConversationType value) {
  assert(::muduo::IMMessage_ConversationType_IsValid(value));
  set_has_conversationtype();
  conversationtype_ = value;
  // @@protoc_insertion_point(field_set:muduo.IMMessage.conversationType)
}

// required .muduo.IMMessage.MessageType messageType = 3;
inline bool IMMessage::has_messagetype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMMessage::set_has_messagetype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMMessage::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMMessage::clear_messagetype() {
  messagetype_ = 1;
  clear_has_messagetype();
}
inline ::muduo::IMMessage_MessageType IMMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:muduo.IMMessage.messageType)
  return static_cast< ::muduo::IMMessage_MessageType >(messagetype_);
}
inline void IMMessage::set_messagetype(::muduo::IMMessage_MessageType value) {
  assert(::muduo::IMMessage_MessageType_IsValid(value));
  set_has_messagetype();
  messagetype_ = value;
  // @@protoc_insertion_point(field_set:muduo.IMMessage.messageType)
}

// optional .muduo.UserInfo userInfo = 5;
inline bool IMMessage::has_userinfo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMMessage::set_has_userinfo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMMessage::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMMessage::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::muduo::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::muduo::UserInfo& IMMessage::userinfo() const {
  // @@protoc_insertion_point(field_get:muduo.IMMessage.userInfo)
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::muduo::UserInfo* IMMessage::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::muduo::UserInfo;
  // @@protoc_insertion_point(field_mutable:muduo.IMMessage.userInfo)
  return userinfo_;
}
inline ::muduo::UserInfo* IMMessage::release_userinfo() {
  clear_has_userinfo();
  ::muduo::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}
inline void IMMessage::set_allocated_userinfo(::muduo::UserInfo* userinfo) {
  delete userinfo_;
  userinfo_ = userinfo;
  if (userinfo) {
    set_has_userinfo();
  } else {
    clear_has_userinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:muduo.IMMessage.userInfo)
}

// optional int64 targetId = 6;
inline bool IMMessage::has_targetid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMMessage::set_has_targetid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMMessage::clear_has_targetid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMMessage::clear_targetid() {
  targetid_ = GOOGLE_LONGLONG(0);
  clear_has_targetid();
}
inline ::google::protobuf::int64 IMMessage::targetid() const {
  // @@protoc_insertion_point(field_get:muduo.IMMessage.targetId)
  return targetid_;
}
inline void IMMessage::set_targetid(::google::protobuf::int64 value) {
  set_has_targetid();
  targetid_ = value;
  // @@protoc_insertion_point(field_set:muduo.IMMessage.targetId)
}

// optional int64 createAt = 7;
inline bool IMMessage::has_createat() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IMMessage::set_has_createat() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IMMessage::clear_has_createat() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IMMessage::clear_createat() {
  createat_ = GOOGLE_LONGLONG(0);
  clear_has_createat();
}
inline ::google::protobuf::int64 IMMessage::createat() const {
  // @@protoc_insertion_point(field_get:muduo.IMMessage.createAt)
  return createat_;
}
inline void IMMessage::set_createat(::google::protobuf::int64 value) {
  set_has_createat();
  createat_ = value;
  // @@protoc_insertion_point(field_set:muduo.IMMessage.createAt)
}

// required string extras = 8;
inline bool IMMessage::has_extras() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IMMessage::set_has_extras() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IMMessage::clear_has_extras() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IMMessage::clear_extras() {
  if (extras_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extras_->clear();
  }
  clear_has_extras();
}
inline const ::std::string& IMMessage::extras() const {
  // @@protoc_insertion_point(field_get:muduo.IMMessage.extras)
  return *extras_;
}
inline void IMMessage::set_extras(const ::std::string& value) {
  set_has_extras();
  if (extras_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extras_ = new ::std::string;
  }
  extras_->assign(value);
  // @@protoc_insertion_point(field_set:muduo.IMMessage.extras)
}
inline void IMMessage::set_extras(const char* value) {
  set_has_extras();
  if (extras_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extras_ = new ::std::string;
  }
  extras_->assign(value);
  // @@protoc_insertion_point(field_set_char:muduo.IMMessage.extras)
}
inline void IMMessage::set_extras(const char* value, size_t size) {
  set_has_extras();
  if (extras_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extras_ = new ::std::string;
  }
  extras_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:muduo.IMMessage.extras)
}
inline ::std::string* IMMessage::mutable_extras() {
  set_has_extras();
  if (extras_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extras_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:muduo.IMMessage.extras)
  return extras_;
}
inline ::std::string* IMMessage::release_extras() {
  clear_has_extras();
  if (extras_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = extras_;
    extras_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMMessage::set_allocated_extras(::std::string* extras) {
  if (extras_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete extras_;
  }
  if (extras) {
    set_has_extras();
    extras_ = extras;
  } else {
    clear_has_extras();
    extras_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:muduo.IMMessage.extras)
}

// -------------------------------------------------------------------

// HistoryMessage

// required int32 id = 1;
inline bool HistoryMessage::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoryMessage::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoryMessage::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoryMessage::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 HistoryMessage::id() const {
  // @@protoc_insertion_point(field_get:muduo.HistoryMessage.id)
  return id_;
}
inline void HistoryMessage::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:muduo.HistoryMessage.id)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace muduo

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::muduo::Response_ErrorCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::muduo::Response_ErrorCode>() {
  return ::muduo::Response_ErrorCode_descriptor();
}
template <> struct is_proto_enum< ::muduo::IMMessage_ConversationType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::muduo::IMMessage_ConversationType>() {
  return ::muduo::IMMessage_ConversationType_descriptor();
}
template <> struct is_proto_enum< ::muduo::IMMessage_MessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::muduo::IMMessage_MessageType>() {
  return ::muduo::IMMessage_MessageType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_query_2eproto__INCLUDED
